/* * ATM Example system - file ATM.java * * copyright (c) 2001 - Russell C. Bjork * */ package edu.gordon.atm;import java.net.InetAddress;import edu.gordon.atm.physical.CardReader;import edu.gordon.atm.physical.CashDispenser;import edu.gordon.atm.physical.CustomerConsole;import edu.gordon.atm.physical.EnvelopeAcceptor;import edu.gordon.atm.physical.Log;import edu.gordon.atm.physical.NetworkToBank;import edu.gordon.atm.physical.OperatorPanel;import edu.gordon.atm.physical.ReceiptPrinter;import edu.gordon.atm.transaction.Deposit;import edu.gordon.atm.transaction.Inquiry;import edu.gordon.atm.transaction.Transaction;import edu.gordon.atm.transaction.Transfer;import edu.gordon.atm.transaction.Withdrawal;import edu.gordon.atm.transaction.Transaction.CardRetained;import edu.gordon.simulation.Observer;import edu.gordon.banking.*;/** Representation for the ATM itself.  An object of this class "owns" *  the objects representing the component parts of the ATM, and the *  communications network, and is responsible for creating customer  *  sessions which then use it to gain access to the component parts. *  This is an active class - when an instance of the class is created, *  a thread is executed that actually runs the system. */ public class ATM implements Observer, Runnable{    /** Constructor     *     *  @param id the unique ID for this ATM     *  @param place the physical location of this ATM     *  @param bankName the name of the bank owning this ATM     *  @param bankAddress the Internet address of the bank     */		private Observer o;	    public ATM(int id, String place, String bankName, InetAddress bankAddress)    {        this.id = id;        this.place = place;        this.bankName = bankName;        this.bankAddress = bankAddress;                // Create objects corresponding to component parts        log = new Log();        //cardReader = new CardReader(this);        cardReader = new CardReader();        cashDispenser = new CashDispenser(log);        customerConsole = new CustomerConsole();        envelopeAcceptor = new EnvelopeAcceptor(log);        networkToBank = new NetworkToBank(log, bankAddress);        //operatorPanel = new OperatorPanel(this);        operatorPanel = new OperatorPanel();        receiptPrinter = new ReceiptPrinter();              // Set up initial conditions when ATM first created                state = OFF_STATE;        switchOn = false;        cardInserted = false;             }  /*      public Status performInvalidPINExtension() throws CustomerConsole.Cancelled, CardRetained    {    	int pin;		Status status = null;		for (int i = 0; i < 3; i ++)		{		pin = getCustomerConsole().readPIN(		"PIN was incorrect\nPlease re-enter your PIN\n" +		"Then press ENTER");		getCustomerConsole().display("");				message.setPIN(pin);		status = getNetworkToBank().sendMessage(message, balances);		if (! status.isInvalidPIN())		{		session.setPIN(pin);		return status;		}		}				getCardReader().retainCard();		getCustomerConsole().display(		"Your card has been retained\nPlease contact the bank.");		try		{		Thread.sleep(5000);		}		catch(InterruptedException e)		{ }		this.getCustomerConsole().display("");				throw new CardRetained();    }  */      /** Peform a transaction.  This method depends on the three abstract methods     *  that follow to perform the operations unique to each type of transaction     *  in the appropriate way.     *     *  @return true if customer indicates a desire to do another transaction;     *          false if customer does not desire to do another transaction     *  @exception CardRetained if card was retained due to too many invalid PIN's     */    public boolean performTransaction(Transaction current_transaction) throws CardRetained, CustomerConsole.Cancelled    {        String doAnotherMessage = "";        Status status = null;        Receipt receipt = null;                        while (true)    // Terminates by return in ASKING_DO_ANOTHER_STATE or exception        {            switch(state)            {                case Transaction.GETTING_SPECIFICS_STATE:                                    try                    {                               	current_transaction.getSpecificsFromCustomer(this.getCustomerConsole());                        this.getCustomerConsole().display("");                        state = Transaction.SENDING_TO_BANK_STATE;                    }                    catch(CustomerConsole.Cancelled e)                    {                        doAnotherMessage = "Last transaction was cancelled";                        state = Transaction.ASKING_DO_ANOTHER_STATE;                    }                                        break;                                    case Transaction.SENDING_TO_BANK_STATE:                                                    status = this.getNetworkToBank().sendMessage(current_transaction.message, current_transaction.balances);                                    if (status.isInvalidPIN())                        state = Transaction.INVALID_PIN_STATE;                    else if (status.isSuccess())                        state = Transaction.COMPLETING_TRANSACTION_STATE;                    else                    {                        doAnotherMessage = status.getMessage();                        state = Transaction.ASKING_DO_ANOTHER_STATE;                    }                                        break;                                case Transaction.INVALID_PIN_STATE:                				// status = performInvalidPINExtension();               				// If customer repeatedly enters invalid PIN's, a				// CardRetained exception is thrown, and this method				// terminates								if (status.isSuccess())				    state = Transaction.COMPLETING_TRANSACTION_STATE;				else				{				    doAnotherMessage = status.getMessage();				    state =Transaction.ASKING_DO_ANOTHER_STATE;				}                    break;                                        case Transaction.COMPLETING_TRANSACTION_STATE:                    try                    {                    	receipt = new Receipt(this.GetInformation(),current_transaction.GetCard(),current_transaction.serialNumber,current_transaction.balances);                        current_transaction.completeTransaction(receipt);                        state = Transaction.PRINTING_RECEIPT_STATE;                    }                    catch(CustomerConsole.Cancelled e)                    {                        doAnotherMessage = "Last transaction was cancelled";                        state = Transaction.ASKING_DO_ANOTHER_STATE;                    }                                        break;                                    case Transaction.PRINTING_RECEIPT_STATE:                                	this.getReceiptPrinter().printReceipt(receipt);                    state = Transaction.ASKING_DO_ANOTHER_STATE;                                        break;                                    case Transaction.ASKING_DO_ANOTHER_STATE:                                    if (doAnotherMessage.length() > 0)                        doAnotherMessage += "\n";                                            try                    {                        String [] yesNoMenu = { "Yes", "No" };                        boolean doAgain = this.getCustomerConsole().readMenuChoice(                            doAnotherMessage +                             "Would you like to do another transaction?",                            yesNoMenu) == 0;                        return doAgain;                    }                    catch(CustomerConsole.Cancelled e)                    {                        return false;                    }            }        }    }    /** Create a transaction of an appropriate type by asking the customer     *  what type of transaction is desired and then returning a newly-created     *  member of the appropriate subclass     *     *  @param edu.gordon.atm the ATM used to communicate with customer     *  @param session the session in which this transaction is being performed     *  @param card the customer's card     *  @param pin the PIN entered by the customer     *  @return a newly created Transaction object of the appropriate type     *  @exception CustomerConsole.Cancelled if the customer presses cancel instead     *         of choosing a transaction type     */    public Transaction makeTransaction(Card card, int pin)                                throws CustomerConsole.Cancelled                  {        int choice = this.getCustomerConsole().readMenuChoice(                "Please choose transaction type", Transaction.TRANSACTION_TYPES_MENU);                        switch(choice)        {            case 0:                            return new Withdrawal(card, pin,this.getCashDispenser());                            case 1:                            return new Deposit( card, pin,this.getNetworkToBank(),this.getEnvelopeAcceptor());                            case 2:                            return new Transfer( card, pin);                            case 3:                            return new Inquiry( card, pin);                            default:                            return null;    // To keep compiler happy - should not happen!        }    }    // Methods corresponding to major responsibilities of the ATM        /** The main program/applet will create a Thread that executes     *  this code.     */    public void run()    {        Session currentSession = null;                while (true)        {            switch(state)            {                case OFF_STATE:                                    customerConsole.display("Not currently available");                    synchronized(this)                    {                        try                        {                             wait();                        }                        catch(InterruptedException e)                        { }                    }                                        if (switchOn)                    {                        performStartup();                        state = IDLE_STATE;                    }                                                                break;                                    case IDLE_STATE:                                    customerConsole.display("Please insert your card");                    cardInserted = false;                                                            synchronized(this)                    {                        try                        {                             wait();                        }                        catch(InterruptedException e)                        { }                    }                                               if (cardInserted)                    {                        currentSession = new Session(this);                        state = SERVING_CUSTOMER_STATE;                    }                    else if (! switchOn)                    {                        performShutdown();                        state = OFF_STATE;                    }                                        break;                            case SERVING_CUSTOMER_STATE:                                                        // The following will not return until the session has                    // completed                                        currentSession.performSession();                                        state = IDLE_STATE;                                        break;                            }        }    }                    /** Inform the ATM that the switch on the operator console has been moved     *  to the "on" position.     */    public synchronized void switchOn()    {        switchOn = true;        notify();    }        /** Inform the ATM that the switch on the operator console has been moved     *  to the "off" position.     */    public synchronized void switchOff()    {        switchOn = false;        notify();    }        /** Inform the ATM that a card has been inserted into the card reader.     */    public synchronized void cardInserted()    {        cardInserted = true;        notify();    }        // The following methods allow objects of other classes to access component    // parts of the ATM        /** Accessor for id     *     *  @return unique id of this ATM     */    public int getID()    {        return id;    }    public ATMInformation GetInformation(){    	return new ATMInformation(this.id,this.place,this.bankName);    }    /** Accessor for place     *     *  @return physical location of this ATM     */    public String getPlace()    {        return place;    }        /** Accessor for bank name     *     *  @return name of bank owning this ATM     */    public String getBankName()    {        return bankName;    }        /** Accessor for card reader     *     *  @return card reader component of this ATM     */    public CardReader getCardReader()    {        return cardReader;    }        /** Accessor for cash dispenser     *     *  @return cash dispenser component of this ATM     */    public CashDispenser getCashDispenser()    {        return cashDispenser;    }        /** Accessor for customer console      *     *  @return customer console component of this ATM     */    public CustomerConsole getCustomerConsole()    {        return customerConsole;    }        /** Accessor for envelope acceptor     *     *  @return envelope acceptor component of this ATM     */    public EnvelopeAcceptor getEnvelopeAcceptor()    {        return envelopeAcceptor;    }        /** Accessor for log     *     *  @return log component of this ATM     */    public Log getLog()    {        return log;    }        /** Accessor for network to bank     *     *  @return network connection to bank of this ATM     */    public NetworkToBank getNetworkToBank()    {        return networkToBank;    }        /** Accessor for operator panel     *     *  @return operator panel component of this ATM     */    public OperatorPanel getOperatorPanel()    {        return operatorPanel;    }        /** Accessor for receipt printer     *     *  @return receipt printer component of this ATM     */    public ReceiptPrinter getReceiptPrinter()    {        return receiptPrinter;    }    // Private methods    /** Perform the System Startup use case when switch is turned on     */    private void performStartup()    {        Money initialCash = operatorPanel.getInitialCash();        cashDispenser.setInitialCash(initialCash);        networkToBank.openConnection();         }        /** Perform the System Shutdown use case when switch is turned off     */    private void performShutdown()    {        networkToBank.closeConnection();    }            // Instance variables recording information about the ATM            /** Unique ID for this ATM     */    private int id;        /** Physical location of this ATM     */    private String place;        /** Name of the bank owning this ATM     */    private String bankName;        /** Internet address of the bank     */    private InetAddress bankAddress;            // Instance variables referring to the omponent parts of the ATM        /** The ATM's card reader     */    private CardReader cardReader;        /** The ATM's cash dispenser     */    private CashDispenser cashDispenser;        /** The ATM's customer console     */    private CustomerConsole customerConsole;        /** The ATM's envelope acceptor     */    private EnvelopeAcceptor envelopeAcceptor;        /** The ATM's log     */    private Log log;        /** The ATM's network connection to the bank     */    private NetworkToBank networkToBank;        /** The ATM's operator panel     */    private OperatorPanel operatorPanel;        /** The ATM's receipt printer     */    private ReceiptPrinter receiptPrinter;        // State information        /** The current state of the ATM - one of the possible values listed below     */    private int state;        /** Becomes true when the operator panel informs the ATM that the switch has     *  been turned on - becomes false when the operator panel informs the ATM     *  that the switch has been turned off.     */    private boolean switchOn;        /** Becomes true when the card reader informs the ATM that a card has been     *  inserted - the ATM will make this false when it has tried to read the     *  card     */    private boolean cardInserted;     // Possible values for state            /** The ATM is off.  The switch must be turned on before it can operate     */    private static final int OFF_STATE = 0;        /** The ATM is on, but idle.  It can service a customer, or it can be shut down     */    private static final int IDLE_STATE = 1;        /** The ATM is servicing a customer.     */    private static final int SERVING_CUSTOMER_STATE = 2;	public void update(Boolean state, Boolean cardInserted) 	{		if(cardInserted != null && cardInserted)		{			cardInserted();		}				if(state != null && state)		{			switchOn();		}		if(state != null && !state)		{			switchOff();		}	}}